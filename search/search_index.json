{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pydrad This package contains various helpers for configuring, parsing, and plotting HYDRAD simulations. The HYDrodynamics and RADiation model is a code for modeling the field-aligned dynamics of coronal loops. Installing this Package Python 3.6+ and the following dependencies are required to run this package: numpy jinja2 asdf (pip only) astropy matplotlib plasmapy (pip only) GitPython (optional) First, clone the repository, $ git clone https://github.com/rice-solar-physics/pydrad.git $ cd pydrad To install all of the needed dependencies, $ pip install -r requirements/requirements/txt Finally, install the pydrad package, $ python setup.py install Testing If you'd like to run the tests, you can install the additional development dependencies, $ pip install -r requirements/requirements-dev.txt and run the tests, $ pytest Note that this step is not necessary to run the code. Additional Resources Below are a few papers describing the HYDRAD code, Bradshaw and Mason (2003a) Bradshaw and Mason (2003b) Bradshaw and Klimchuk (2011) Bradshaw and Cargill (2013)","title":"Getting Started"},{"location":"#pydrad","text":"This package contains various helpers for configuring, parsing, and plotting HYDRAD simulations. The HYDrodynamics and RADiation model is a code for modeling the field-aligned dynamics of coronal loops.","title":"pydrad"},{"location":"#installing-this-package","text":"Python 3.6+ and the following dependencies are required to run this package: numpy jinja2 asdf (pip only) astropy matplotlib plasmapy (pip only) GitPython (optional) First, clone the repository, $ git clone https://github.com/rice-solar-physics/pydrad.git $ cd pydrad To install all of the needed dependencies, $ pip install -r requirements/requirements/txt Finally, install the pydrad package, $ python setup.py install","title":"Installing this Package"},{"location":"#testing","text":"If you'd like to run the tests, you can install the additional development dependencies, $ pip install -r requirements/requirements-dev.txt and run the tests, $ pytest Note that this step is not necessary to run the code.","title":"Testing"},{"location":"#additional-resources","text":"Below are a few papers describing the HYDRAD code, Bradshaw and Mason (2003a) Bradshaw and Mason (2003b) Bradshaw and Klimchuk (2011) Bradshaw and Cargill (2013)","title":"Additional Resources"},{"location":"configure/","text":"Configure a Simulation HYDRAD requires setting many different configuration files, making it difficult and tedious to configure a simulation by hand. Fortunately, the pydrad package makes it easy to quickly configure a new simulation using Python. Rather than editing each configuration file individually, an entire simulation can be configured using a single Python dictionary . Below is an example of a dictionary for configuring a simulation of a 80 Mm loop lasting 5000 s with a single heating pulse using an adaptive grid. Many of the configuration options have been excluded for brevity. A complete list of configuration parameters can be found in the section below . >>> import astropy.units as u >>> config_dict = { 'general' : { 'total_time' : 5e3 * u . s , 'loop_length' : 80 * u . Mm , 'footpoint_height' : 5e8 * u . cm , # ... other config parameters ... }, 'initial_conditions' : { 'footpoint_temperature' : 2e4 * u . K , 'footpoint_density' : 1e11 * u . cm ** ( - 3 ), 'isothermal' : False , # ... other config parameters ... }, 'radiation' : { 'use_power_law_radiative_losses' : True , # ... other config parameters ... }, 'heating' : { 'heat_electrons' : True , 'events' : [ { 'time_start' : 0. * u . s , 'rise_duration' : 100 * u . s , 'decay_duration' : 100 * u . s , 'total_duration' : 200 * u . s , 'location' : 4e9 * u . cm , 'scale_height' : 1e300 * u . cm , 'rate' : 0.1 * u . erg / u . s / ( u . cm ** 3 ), }, ], }, 'solver' : { 'safety_radiation' : 1.0 , 'safety_conduction' : 1.0 , 'safety_advection' : 1.0 , 'safety_atomic' : 1.0 , # ... other grid parameters ... }, 'grid' : { 'adapt' : True , # ... other grid parameters ... } } The next step is to pass it to the pydrad class which can parse it and print the needed configuration files, >>> from pydrad import configure >>> c = configure . Configure ( config ) And we can preview the different configuration files that setup the HYDRAD simulation, >>> print ( c . initial_conditions_header ) // **** // * // * #defines for configuring the hydrostatic model // * // * (c) Dr. Stephen J. Bradshaw // * // * Source code generated by pydrad on 2018-03-26_00.38.59 // * // **** // **** Output **** // **** End of Output **** // **** Physics **** #include \"../../Radiation_Model/source/config.h\" // **** Solver **** #define EPSILON 0.01 // **** Grid **** #define ADAPT #define MIN_CELLS 150 #define MAX_CELLS 30000 #define MAX_REFINEMENT_LEVEL 12 #define MIN_DS 1.0 #define MAX_VARIATION 1.1 >>> print ( c . initial_conditions_cfg ) Initial_Conditions / profiles / initial . amr 8000000000 . 0 0 . 0 500000000 . 0 20000 . 0 100000000000 . 0 4000000000 . 0 1 e + 300 - 8 . 0 2 . 0 0 . 001 10000 . 0 Configuration file generated by pydrad on 2018 - 03 - 26 _00 . 42 . 20 >>> print ( c . hydrad_header ) // **** // * // * #defines for configuring the hydrodynamic model // * // * (c) Dr. Stephen J. Bradshaw // * // * Source code generated by pydrad on 2018-03-26_00.59.38 // * // **** // **** Output **** #define WRITE_FILE_PHYSICAL #define OUTPUT_EVERY_N_TIME_STEPS 1000 // **** End of Output **** // **** Physics **** #include \"../../Heating_Model/source/config.h\" #include \"../../Radiation_Model/source/config.h\" #define HEAT_FLUX_LIMITING_COEFFICIENT 1.0 #define TIME_STEP_LIMIT 1e-10 #include \"collisions.h\" // **** End of Physics **** // **** Solver **** #define SAFETY_RADIATION 1.0 #define SAFETY_CONDUCTION 1.0 #define SAFETY_ADVECTION 1.0 #define SAFETY_VISCOSITY 1.0 #define TIME_STEP_INCREASE_LIMIT 1.05 #define MINIMUM_RADIATION_TEMPERATURE 20000.0 #define ZERO_OVER_TEMPERATURE_INTERVAL 500.0 #define MINIMUM_TEMPERATURE 10000.0 // **** End of Solver **** // **** Grid **** #define MAX_REFINEMENT_LEVEL 12 #define ADAPT #define REFINE_ON_ELECTRON_ENERGY #define MIN_FRAC_DIFF 0.1 #define MAX_FRAC_DIFF 0.2 #define LINEAR_RESTRICTION // **** End of Grid **** To print all configuration files, run the initial conditions, and copy all of this to a new location, c . setup_simulation ( '/path/to/simulation/dir/new_hydrad_sim' , base_path = '/path/to/clean/HYDRAD' ) This will create all of the needed input files from the options in config , compile the initial conditions code, run Initial_Conditions.exe , compile the main HYDRAD, and copy it all to the directory /path/to/simulation/dir/new_hydrad_sim . Setting a Default Configuration HYDRAD requires a lot of configuration options and it can be annoying to have put them all in a configuration file. To avoid this, you can load a default configuration from an ASDF file , a human-readable, structured plain text file in the YAML format. These ASDF files are structured just like the config directory and can be easily read and written. To load a configuration from a file, config = configure . Configure . load_config ( '/path/to/config/defaults.asdf' ) # Update configuration options in config c = configure . Configure ( config ) And to save the configuration to disk, c . save_config ( '/path/to/config/my_config.asdf' ) An example default configuration file can be found in the root of the pydrad repository . Overriding Default Templates If you make local modifications to the HYDRAD code, you may need configuration options not in the included templates. To use custom configuration options, you can inject your own modified templates of the configuration files which take advantage of any custom options. To see the available templates, >>> c . templates [ 'coefficients.cfg' , 'collisions.h' , 'heating.cfg' , 'heating.config.h' , 'hydrad.cfg' , 'hydrad.config.h' , 'initial_conditions.cfg' , 'initial_conditions.config.h' , 'radiation.config.h' , 'radiation.elements.cfg' ] Say we want to add an option, MY_NEW_PARAM to the collisions.h file. To get the current unrendered template, >>> print ( c . get_raw_template ( 'collisions.h' )) // **** // * // * #defines for configuring the shortest collisional coupling timescale // * // * (c) Dr. Stephen J. Bradshaw // * // * Source code generated by pydrad on {{ date }} // * // **** // **** Physics **** #define MINIMUM_COLLISIONAL_COUPLING_TIME_SCALE {{ general.minimum_collisional_coupling_timescale | units_filter ( 's' ) }} {% if general.force_single_fluid - %} #define FORCE_SINGLE_FLUID {% - endif %} // **** End of Physics **** We can then create a new template with our new value, new_collisions = \"\"\"// **** // * // * #defines for configuring the shortest collisional coupling timescale // * // * (c) Dr. Stephen J. Bradshaw // * // * Source code generated by pydrad on {{ date }} // * // **** // **** Physics **** #define MINIMUM_COLLISIONAL_COUPLING_TIME_SCALE {{ general.minimum_collisional_coupling_timescale | units_filter('s') }} { % i f general.force_single_fluid -%}#define FORCE_SINGLE_FLUID{ %- e ndif %} // **** End of Physics **** #define MY_NEW_PARAM {{ general.my_new_param }}\"\"\" add our new parameter to the configuration directory, config [ 'general' ][ 'my_new_param' ] = 100 and then pass the template to the Configure object, c_new = Configure ( config , templates = { 'collisions.h' : new_collisions }) Now take a look at your custom rendered template, >>> print ( c_new . collisions_header ) // **** // * // * # defines for configuring the shortest collisional coupling timescale // * // * ( c ) Dr . Stephen J . Bradshaw // * // * Source code generated by pydrad on 2018 - 09 - 01 _15 . 14 . 17 // * // **** // **** Physics **** # define MINIMUM_COLLISIONAL_COUPLING_TIME_SCALE 0 . 01 // **** End of Physics **** # define MY_NEW_PARAM 100 Configuration Parameters The tables below give an exhaustive list of all of the different HYDRAD configuration options. If the units are listed, the input must have units that can be converted to the listed unit with the Astropy units module , e.g. loop_length can be input in Mm. General Name Description Type Units total_time Total duration of the simulation int s output_interval How often results are printed to file int s loop_length Footpoint-to-footpoint distance of the coronal loop float cm loop_inclination Angle between loop and surface normal float degree footpoint_height Length of the chromosphere float cm poly_fit_gravity Coefficients (in order of increasing exponent) for 6th order polynomial fit to the field-aligned gravitational acceleration array-like poly_fit_magnetic_field Coefficients (in order of increasing exponent) for 6th order polynomial fit to the magnetic field strength along the loop array-like logging_frequency Frequency (in number of timesteps) that progress is printed to the screen int initial_amr_file Adaptive mesh file to initialize loop from; if not given, uses the result from the initial conditions code str write_file_physical Toggle writing .phy solutions file bool write_file_ion_populations Toggle writing .ine file bool write_file_hydrogen_level_populations Toggle writing .Hstate file bool write_file_timescales Toggle writing .scl file bool write_file_equation_terms Toggle writing .trm bool heat_flux_limiting_coefficient See Eq. A15 of BC13 float heat_flux_timestep_limit Minimum value the heat flux will limit timestep to float s use_kinetic_model Toggle using kinetic model for heat flux bool minimum_collisional_coupling_timescale float s force_single_fluid If true, force electron and ion quantities to be equal bool use_openmp If true, parallelize over threads with OpenMP . This option is most useful when including a NLTE chromosphere. bool open_field If true, one footpoint is assumed to not connect to the surface bool force_symmetry bool Initial Conditions Name Description Type Units footpoint_temperature Temperature at the loop footpoint float K footpoint_density Density at the loop footpoint float cm ^{-3} ^{-3} heating_location Loop coordinate where equilibrium heat is injected float cm heating_scale_height Spatial scale of the injected equilibrium heating float cm isothermal If true, inital temperature profile is uniform bool heating_range_lower_bound Lower bound on rate search range float \\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1} \\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1} heating_range_upper_bound Upper bound on rate search range float \\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1} \\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1} heating_range_step_size Resolution of heating search range float heating_range_fine_tuning float use_poly_fit_gravity If True, use polynomial fit to gravitational profile bool use_poly_fit_magnetic_field If True, use polynomial fit to magnetic field strength bool Heating Name Description Type Units heat_electrons If false, only ions are heated bool beam Toggle beam heating model bool alfven_wave Toggle Alfv\u00e9n wave heating model bool background Parameters for configuring background heating profile dict events List of heating event properties list The background dict can have the following keys. If it is not included at all, no background heating is applied. Name Description Type Units use_initial_conditions If true, use the heating parameters from the initial conditions and the computed equilibrium heating rate. If present, all other keys are ignored. bool location Location of the energy deposition float cm scale_height Spatial scale of the energy deposition float cm rate Maximum heating rate float \\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1} \\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1} Each entry in the events list should be a dictionary with the following seven keys (and appropriate units) corresponding to each heating event, Name Units time_start s rise_duration s decay_duration s total_duration s location cm scale_height cm rate \\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1} \\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1} Radiation Name Description Type Units use_power_law_radiative_losses If true, use piecewise power-law to calculate radiative losses bool lookup_table Path (relative to the root of the HYDRAD directory) to lookup table for radiative losses. Ignored unless use_power_law_radiative_losses is also set. str decouple_ionization_state_solver If true, the non-equilibrium population fractions are not fed back into the radiative loss calculation. This option will be ignored unless a list of elements is also passed to elements_nonequilibrium. If use_power_law_radiative_losses is false, the equilibrium population fractions will be used to calculate the radiative losses. bool density_dependent_rates bool optically_thick_radiation If true, include optically thick lines in radiative losses bool nlte_chromosphere Treat the chromosphere as being in non-local thermal equilibrium. NOTE: This may significantly increase the computation time. bool minimum_density_limit Density floor of the corona. This option is required if nlte_chromosphere is true float cm ^{-3} ^{-3} ranges_dataset Temperature and density ranges dataset str emissivity_dataset Name of emissivity dataset str abundance_dataset Name of abundance dataset str rates_dataset Name of ionization/recombination rates dataset str elements_equilibrium Assume ionization equilibrium when calculating these population fractions list elements_nonequilibrium Account for time-dependent ionization when calculating these population fractions list In the lists of equilibrium and non-equilibrium elements, each entry can either be the atomic symbol, number, or the element name. As an example, each entry in the list below (which includes hydrogen, helium, carbon, and iron) is a valid element identifier, elements = [ 'hydrogen' , 'He' , 'c' , 26 ] Solver Name Description Type Units epsilon float safety_radiation float safety_conduction float safety_advection float safety_atomic float safety_viscosity float cutoff_ion_fraction Population fractions below this value are set to 0 float epsilon_d Safety factor for ion population solver; see B09 float epsilon_r Safety factor for ion population solver; see B09 float timestep_increase_limit Allowed fractional difference (between 0 and 1) from 1 timestep to next float relative_viscous_timescale float minimum_radiation_temperature float K zero_over_temperature_interval Temperature interval over which the chromospheric radiative losses are set to zero float K minimum_temperature float K maximum_optically_thin_density float \\mathrm{cm}^{-3} \\mathrm{cm}^{-3} cutoff_temperature_fraction Ratio between cutoff temperature and peak temperature. If set, use the method of JB19 to model the transition region. float Grid Name Description Type Units adapt Toggle using adaptive mesh refinement bool adapt_every_n_time_steps How often to adapt on time step int maximum_cell_width The maximum allowed width of any grid cell float cm maximum_refinement_level The maximum number of times a grid cell can be split; see BC13 int minimum_delta_s Smallest allowed grid cell width in the initial setup float cm maximum_variation float refine_on_density bool refine_on_electron_energy bool refine_on_hydrogen_energy bool minimum_fractional_difference Minimum allowed difference (between 0 and 1) between adjacent cells float maximum_fractional_difference Maximum allowed difference (between 0 and 1) between adjacent cells float linear_restriction bool enforce_conservation bool","title":"Configuring a Simulation"},{"location":"configure/#configure-a-simulation","text":"HYDRAD requires setting many different configuration files, making it difficult and tedious to configure a simulation by hand. Fortunately, the pydrad package makes it easy to quickly configure a new simulation using Python. Rather than editing each configuration file individually, an entire simulation can be configured using a single Python dictionary . Below is an example of a dictionary for configuring a simulation of a 80 Mm loop lasting 5000 s with a single heating pulse using an adaptive grid. Many of the configuration options have been excluded for brevity. A complete list of configuration parameters can be found in the section below . >>> import astropy.units as u >>> config_dict = { 'general' : { 'total_time' : 5e3 * u . s , 'loop_length' : 80 * u . Mm , 'footpoint_height' : 5e8 * u . cm , # ... other config parameters ... }, 'initial_conditions' : { 'footpoint_temperature' : 2e4 * u . K , 'footpoint_density' : 1e11 * u . cm ** ( - 3 ), 'isothermal' : False , # ... other config parameters ... }, 'radiation' : { 'use_power_law_radiative_losses' : True , # ... other config parameters ... }, 'heating' : { 'heat_electrons' : True , 'events' : [ { 'time_start' : 0. * u . s , 'rise_duration' : 100 * u . s , 'decay_duration' : 100 * u . s , 'total_duration' : 200 * u . s , 'location' : 4e9 * u . cm , 'scale_height' : 1e300 * u . cm , 'rate' : 0.1 * u . erg / u . s / ( u . cm ** 3 ), }, ], }, 'solver' : { 'safety_radiation' : 1.0 , 'safety_conduction' : 1.0 , 'safety_advection' : 1.0 , 'safety_atomic' : 1.0 , # ... other grid parameters ... }, 'grid' : { 'adapt' : True , # ... other grid parameters ... } } The next step is to pass it to the pydrad class which can parse it and print the needed configuration files, >>> from pydrad import configure >>> c = configure . Configure ( config ) And we can preview the different configuration files that setup the HYDRAD simulation, >>> print ( c . initial_conditions_header ) // **** // * // * #defines for configuring the hydrostatic model // * // * (c) Dr. Stephen J. Bradshaw // * // * Source code generated by pydrad on 2018-03-26_00.38.59 // * // **** // **** Output **** // **** End of Output **** // **** Physics **** #include \"../../Radiation_Model/source/config.h\" // **** Solver **** #define EPSILON 0.01 // **** Grid **** #define ADAPT #define MIN_CELLS 150 #define MAX_CELLS 30000 #define MAX_REFINEMENT_LEVEL 12 #define MIN_DS 1.0 #define MAX_VARIATION 1.1 >>> print ( c . initial_conditions_cfg ) Initial_Conditions / profiles / initial . amr 8000000000 . 0 0 . 0 500000000 . 0 20000 . 0 100000000000 . 0 4000000000 . 0 1 e + 300 - 8 . 0 2 . 0 0 . 001 10000 . 0 Configuration file generated by pydrad on 2018 - 03 - 26 _00 . 42 . 20 >>> print ( c . hydrad_header ) // **** // * // * #defines for configuring the hydrodynamic model // * // * (c) Dr. Stephen J. Bradshaw // * // * Source code generated by pydrad on 2018-03-26_00.59.38 // * // **** // **** Output **** #define WRITE_FILE_PHYSICAL #define OUTPUT_EVERY_N_TIME_STEPS 1000 // **** End of Output **** // **** Physics **** #include \"../../Heating_Model/source/config.h\" #include \"../../Radiation_Model/source/config.h\" #define HEAT_FLUX_LIMITING_COEFFICIENT 1.0 #define TIME_STEP_LIMIT 1e-10 #include \"collisions.h\" // **** End of Physics **** // **** Solver **** #define SAFETY_RADIATION 1.0 #define SAFETY_CONDUCTION 1.0 #define SAFETY_ADVECTION 1.0 #define SAFETY_VISCOSITY 1.0 #define TIME_STEP_INCREASE_LIMIT 1.05 #define MINIMUM_RADIATION_TEMPERATURE 20000.0 #define ZERO_OVER_TEMPERATURE_INTERVAL 500.0 #define MINIMUM_TEMPERATURE 10000.0 // **** End of Solver **** // **** Grid **** #define MAX_REFINEMENT_LEVEL 12 #define ADAPT #define REFINE_ON_ELECTRON_ENERGY #define MIN_FRAC_DIFF 0.1 #define MAX_FRAC_DIFF 0.2 #define LINEAR_RESTRICTION // **** End of Grid **** To print all configuration files, run the initial conditions, and copy all of this to a new location, c . setup_simulation ( '/path/to/simulation/dir/new_hydrad_sim' , base_path = '/path/to/clean/HYDRAD' ) This will create all of the needed input files from the options in config , compile the initial conditions code, run Initial_Conditions.exe , compile the main HYDRAD, and copy it all to the directory /path/to/simulation/dir/new_hydrad_sim .","title":"Configure a Simulation"},{"location":"configure/#setting-a-default-configuration","text":"HYDRAD requires a lot of configuration options and it can be annoying to have put them all in a configuration file. To avoid this, you can load a default configuration from an ASDF file , a human-readable, structured plain text file in the YAML format. These ASDF files are structured just like the config directory and can be easily read and written. To load a configuration from a file, config = configure . Configure . load_config ( '/path/to/config/defaults.asdf' ) # Update configuration options in config c = configure . Configure ( config ) And to save the configuration to disk, c . save_config ( '/path/to/config/my_config.asdf' ) An example default configuration file can be found in the root of the pydrad repository .","title":"Setting a Default Configuration"},{"location":"configure/#overriding-default-templates","text":"If you make local modifications to the HYDRAD code, you may need configuration options not in the included templates. To use custom configuration options, you can inject your own modified templates of the configuration files which take advantage of any custom options. To see the available templates, >>> c . templates [ 'coefficients.cfg' , 'collisions.h' , 'heating.cfg' , 'heating.config.h' , 'hydrad.cfg' , 'hydrad.config.h' , 'initial_conditions.cfg' , 'initial_conditions.config.h' , 'radiation.config.h' , 'radiation.elements.cfg' ] Say we want to add an option, MY_NEW_PARAM to the collisions.h file. To get the current unrendered template, >>> print ( c . get_raw_template ( 'collisions.h' )) // **** // * // * #defines for configuring the shortest collisional coupling timescale // * // * (c) Dr. Stephen J. Bradshaw // * // * Source code generated by pydrad on {{ date }} // * // **** // **** Physics **** #define MINIMUM_COLLISIONAL_COUPLING_TIME_SCALE {{ general.minimum_collisional_coupling_timescale | units_filter ( 's' ) }} {% if general.force_single_fluid - %} #define FORCE_SINGLE_FLUID {% - endif %} // **** End of Physics **** We can then create a new template with our new value, new_collisions = \"\"\"// **** // * // * #defines for configuring the shortest collisional coupling timescale // * // * (c) Dr. Stephen J. Bradshaw // * // * Source code generated by pydrad on {{ date }} // * // **** // **** Physics **** #define MINIMUM_COLLISIONAL_COUPLING_TIME_SCALE {{ general.minimum_collisional_coupling_timescale | units_filter('s') }} { % i f general.force_single_fluid -%}#define FORCE_SINGLE_FLUID{ %- e ndif %} // **** End of Physics **** #define MY_NEW_PARAM {{ general.my_new_param }}\"\"\" add our new parameter to the configuration directory, config [ 'general' ][ 'my_new_param' ] = 100 and then pass the template to the Configure object, c_new = Configure ( config , templates = { 'collisions.h' : new_collisions }) Now take a look at your custom rendered template, >>> print ( c_new . collisions_header ) // **** // * // * # defines for configuring the shortest collisional coupling timescale // * // * ( c ) Dr . Stephen J . Bradshaw // * // * Source code generated by pydrad on 2018 - 09 - 01 _15 . 14 . 17 // * // **** // **** Physics **** # define MINIMUM_COLLISIONAL_COUPLING_TIME_SCALE 0 . 01 // **** End of Physics **** # define MY_NEW_PARAM 100","title":"Overriding Default Templates"},{"location":"configure/#configuration-parameters","text":"The tables below give an exhaustive list of all of the different HYDRAD configuration options. If the units are listed, the input must have units that can be converted to the listed unit with the Astropy units module , e.g. loop_length can be input in Mm.","title":"Configuration Parameters"},{"location":"configure/#general","text":"Name Description Type Units total_time Total duration of the simulation int s output_interval How often results are printed to file int s loop_length Footpoint-to-footpoint distance of the coronal loop float cm loop_inclination Angle between loop and surface normal float degree footpoint_height Length of the chromosphere float cm poly_fit_gravity Coefficients (in order of increasing exponent) for 6th order polynomial fit to the field-aligned gravitational acceleration array-like poly_fit_magnetic_field Coefficients (in order of increasing exponent) for 6th order polynomial fit to the magnetic field strength along the loop array-like logging_frequency Frequency (in number of timesteps) that progress is printed to the screen int initial_amr_file Adaptive mesh file to initialize loop from; if not given, uses the result from the initial conditions code str write_file_physical Toggle writing .phy solutions file bool write_file_ion_populations Toggle writing .ine file bool write_file_hydrogen_level_populations Toggle writing .Hstate file bool write_file_timescales Toggle writing .scl file bool write_file_equation_terms Toggle writing .trm bool heat_flux_limiting_coefficient See Eq. A15 of BC13 float heat_flux_timestep_limit Minimum value the heat flux will limit timestep to float s use_kinetic_model Toggle using kinetic model for heat flux bool minimum_collisional_coupling_timescale float s force_single_fluid If true, force electron and ion quantities to be equal bool use_openmp If true, parallelize over threads with OpenMP . This option is most useful when including a NLTE chromosphere. bool open_field If true, one footpoint is assumed to not connect to the surface bool force_symmetry bool","title":"General"},{"location":"configure/#initial-conditions","text":"Name Description Type Units footpoint_temperature Temperature at the loop footpoint float K footpoint_density Density at the loop footpoint float cm ^{-3} ^{-3} heating_location Loop coordinate where equilibrium heat is injected float cm heating_scale_height Spatial scale of the injected equilibrium heating float cm isothermal If true, inital temperature profile is uniform bool heating_range_lower_bound Lower bound on rate search range float \\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1} \\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1} heating_range_upper_bound Upper bound on rate search range float \\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1} \\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1} heating_range_step_size Resolution of heating search range float heating_range_fine_tuning float use_poly_fit_gravity If True, use polynomial fit to gravitational profile bool use_poly_fit_magnetic_field If True, use polynomial fit to magnetic field strength bool","title":"Initial Conditions"},{"location":"configure/#heating","text":"Name Description Type Units heat_electrons If false, only ions are heated bool beam Toggle beam heating model bool alfven_wave Toggle Alfv\u00e9n wave heating model bool background Parameters for configuring background heating profile dict events List of heating event properties list The background dict can have the following keys. If it is not included at all, no background heating is applied. Name Description Type Units use_initial_conditions If true, use the heating parameters from the initial conditions and the computed equilibrium heating rate. If present, all other keys are ignored. bool location Location of the energy deposition float cm scale_height Spatial scale of the energy deposition float cm rate Maximum heating rate float \\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1} \\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1} Each entry in the events list should be a dictionary with the following seven keys (and appropriate units) corresponding to each heating event, Name Units time_start s rise_duration s decay_duration s total_duration s location cm scale_height cm rate \\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1} \\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1}","title":"Heating"},{"location":"configure/#radiation","text":"Name Description Type Units use_power_law_radiative_losses If true, use piecewise power-law to calculate radiative losses bool lookup_table Path (relative to the root of the HYDRAD directory) to lookup table for radiative losses. Ignored unless use_power_law_radiative_losses is also set. str decouple_ionization_state_solver If true, the non-equilibrium population fractions are not fed back into the radiative loss calculation. This option will be ignored unless a list of elements is also passed to elements_nonequilibrium. If use_power_law_radiative_losses is false, the equilibrium population fractions will be used to calculate the radiative losses. bool density_dependent_rates bool optically_thick_radiation If true, include optically thick lines in radiative losses bool nlte_chromosphere Treat the chromosphere as being in non-local thermal equilibrium. NOTE: This may significantly increase the computation time. bool minimum_density_limit Density floor of the corona. This option is required if nlte_chromosphere is true float cm ^{-3} ^{-3} ranges_dataset Temperature and density ranges dataset str emissivity_dataset Name of emissivity dataset str abundance_dataset Name of abundance dataset str rates_dataset Name of ionization/recombination rates dataset str elements_equilibrium Assume ionization equilibrium when calculating these population fractions list elements_nonequilibrium Account for time-dependent ionization when calculating these population fractions list In the lists of equilibrium and non-equilibrium elements, each entry can either be the atomic symbol, number, or the element name. As an example, each entry in the list below (which includes hydrogen, helium, carbon, and iron) is a valid element identifier, elements = [ 'hydrogen' , 'He' , 'c' , 26 ]","title":"Radiation"},{"location":"configure/#solver","text":"Name Description Type Units epsilon float safety_radiation float safety_conduction float safety_advection float safety_atomic float safety_viscosity float cutoff_ion_fraction Population fractions below this value are set to 0 float epsilon_d Safety factor for ion population solver; see B09 float epsilon_r Safety factor for ion population solver; see B09 float timestep_increase_limit Allowed fractional difference (between 0 and 1) from 1 timestep to next float relative_viscous_timescale float minimum_radiation_temperature float K zero_over_temperature_interval Temperature interval over which the chromospheric radiative losses are set to zero float K minimum_temperature float K maximum_optically_thin_density float \\mathrm{cm}^{-3} \\mathrm{cm}^{-3} cutoff_temperature_fraction Ratio between cutoff temperature and peak temperature. If set, use the method of JB19 to model the transition region. float","title":"Solver"},{"location":"configure/#grid","text":"Name Description Type Units adapt Toggle using adaptive mesh refinement bool adapt_every_n_time_steps How often to adapt on time step int maximum_cell_width The maximum allowed width of any grid cell float cm maximum_refinement_level The maximum number of times a grid cell can be split; see BC13 int minimum_delta_s Smallest allowed grid cell width in the initial setup float cm maximum_variation float refine_on_density bool refine_on_electron_energy bool refine_on_hydrogen_energy bool minimum_fractional_difference Minimum allowed difference (between 0 and 1) between adjacent cells float maximum_fractional_difference Maximum allowed difference (between 0 and 1) between adjacent cells float linear_restriction bool enforce_conservation bool","title":"Grid"},{"location":"parse/","text":"Parse the Results HYDRAD prints all results to the Results directory in the main code directory. These filenames are in the format profile{index}.{ext} where index is the timestep number and ext can be one of the following filetypes, phy -- main physics results file containing temperature, density, etc. amr -- data related to the adapative mesh trm -- equation terms at each grid cell Parsing all of these files can be difficult. pydrad provides a convenient object, Strand , for easily accessing the data associated with a particular HYDRAD run. To create a Strand object, >>> from pydrad.parse import Strand >>> s = Strand ( '/path/to/hydrad_dir' ) >>> s . time # simulation time array The Strand object can be indexed to get the sets of results at a particular timestep, >>> s [ 0 ] >>> s [ 100 ] which returns a Profile object. The resulting Profile object has attributes for getting at the hydrodynamic quantities, >>> p = s [ 0 ] >>> p . electron_temperature >>> p . ion_density >>> p . velocity See the API for the parse subpackage for a list of all available attributes.","title":"Parsing the Results"},{"location":"parse/#parse-the-results","text":"HYDRAD prints all results to the Results directory in the main code directory. These filenames are in the format profile{index}.{ext} where index is the timestep number and ext can be one of the following filetypes, phy -- main physics results file containing temperature, density, etc. amr -- data related to the adapative mesh trm -- equation terms at each grid cell Parsing all of these files can be difficult. pydrad provides a convenient object, Strand , for easily accessing the data associated with a particular HYDRAD run. To create a Strand object, >>> from pydrad.parse import Strand >>> s = Strand ( '/path/to/hydrad_dir' ) >>> s . time # simulation time array The Strand object can be indexed to get the sets of results at a particular timestep, >>> s [ 0 ] >>> s [ 100 ] which returns a Profile object. The resulting Profile object has attributes for getting at the hydrodynamic quantities, >>> p = s [ 0 ] >>> p . electron_temperature >>> p . ion_density >>> p . velocity See the API for the parse subpackage for a list of all available attributes.","title":"Parse the Results"},{"location":"plot/","text":"","title":"Plotting"},{"location":"api/configure/","text":"pydrad.configure Programatically configure HYDRAD simulations Configure Configure ( self , config , ** kwargs ) Configure HYDRAD simulations from a single Python dict Parameters config ( dict ) : All input parameters for configuring simulation templates ( dict ) : Templates to override defaults, optional load_config Configure . load_config ( filename ) Load a base configuration from an ASDF file Parameters filename ( str ) : Path to ASDF configuration file save_config Configure . save_config ( self , filename ) Save the simulation configuration as an ASDF file Parameters filename ( str ) : Path to YAML configuration file setup_simulation Configure . setup_simulation ( self , output_path , base_path , run_initial_conditions = True , ** kwargs ) Setup a HYDRAD simulation with desired outputs from a clean copy Parameters output_path ( str ) : Path to new copy of HYDRAD base_path ( str ) : Path to existing HYDRAD run_initial_conditions ( bool ) : If True, compile and run the initial conditions code setup_initial_conditions Configure . setup_initial_conditions ( self , root_dir , execute = True ) Compile and execute code to get the initial loop profile Parameters root_dir ( str ) : execute ( bool ) : If True (default), compute initial conditions get_equilibrium_heating_rate Configure . get_equilibrium_heating_rate ( self , root_dir ) Read equilibrium heating rate from initial conditions results Parameters root_dir ( str ) : Path to HYDRAD directory setup_hydrad Configure . setup_hydrad ( self , root_dir ) Compile HYDRAD code with appropriate header and config files Parameters root_dir ( str ) : date Return the current date templates List of available templates get_raw_template Configure . get_raw_template ( self , name ) Return the unrendered template. initial_conditions_cfg Initial conditions configuration file, Initial_Conditions/config/initial_conditions.cfg initial_conditions_header Initial conditions header file, Initial_Conditions/source/config.h hydrad_cfg HYDRAD configuration file, HYDRAD/config/hydrad.cfg hydrad_header HYDRAD header file, HYDRAD/source/config.h heating_cfg Heating model configuration file, Heating_Model/config/heating.cfg . If background heating is enabled and you want to use the equilibrium values, you must run the initial conditions and set the equilibrium_heating_rate attribute first. heating_header Heating model header file, Heating_Model/source/config.h beam_heating_cfg Beam heating model configuration file. radiation_equilibrium_cfg Equilibrium elements configuration file, Radiation_Model/config/elements_eq.cfg radiation_nonequilibrium_cfg Non-equilibrium elements configuration file, Radiation_Model/config/elements_neq.cfg radiation_header Radiation model header file, Radiation_Model/source/config.h collisions_header Collisions header file, HYDRAD/source/collisions.h poly_fit_magnetic_field Sixth-order polynomial fit coefficients for computing flux tube expansion poly_fit_gravity Sixth-order polynomial fit coefficients for computing gravitational acceleration minimum_cells Minimum allowed number of grid cells, n_{min}=\\lceil L/\\Delta s_{max}\\rceil n_{min}=\\lceil L/\\Delta s_{max}\\rceil , where L L is the loop length and \\Delta s_{max} \\Delta s_{max} is the maximum allowed grid cell width. maximum_cells Maximum allowed number of grid cells, n_{max}=\\lfloor 2^{L_R}/n_{min}\\rfloor n_{max}=\\lfloor 2^{L_R}/n_{min}\\rfloor , where L_R L_R is the maximum refinement level and n_{min} n_{min} is the minimum allowed number of grid cells.","title":"pydrad.configure"},{"location":"api/parse/","text":"pydrad.parse Objects for easily parsing HYDRAD results Strand Strand ( self , hydrad_root , ** kwargs ) Container for parsing HYDRAD results Parameters hydrad_root ( str ) : Path to HYDRAD simulation directory to_hdf5 Strand . to_hdf5 ( self , filename , * variables ) Save variables to an HDF5 file Parameters filename ( str or path-like) : path to HDF file variables ( str ) : Names of variables to save to file time Simulation time loop_length Footpoint-to-footpoint loop length initial_conditions Profile for the solutions to the hydrostatic equations used as initial conditions. peek Strand . peek ( self , ** kwargs ) Quick look at all profiles for the run on a single plot. Takes the same keyword arguments as pydrad.visualize.plot_strand peek_time_distance Strand . peek_time_distance ( self , quantities , delta_s : Unit ( \"cm\" ), ** kwargs ) Quick look at time-distance plots of various quantities. Takes the same keyword arguments as pydrad.visualize.plot_time_distance animate Strand . animate ( self , ** kwargs ) Simple animation of time-dependent loop profiles. Takes the same keyword arguments as pydrad.visualize.animate_strand get_uniform_grid Strand . get_uniform_grid ( self , delta_s : Unit ( \"cm\" )) Create a spatial grid with uniform spacing delta_s . Parameters: delta_s ( astropy.units.Quantity ): Spacing between each grid point to_constant_grid Strand . to_constant_grid ( self , name , grid : Unit ( \"cm\" )) Interpolate a given quantity onto a spatial grid that is the same at each time step. Parameters name ( str ) : Name of quantity grid ( astropy.units.Quantity ) : Spatial grid to interpolate onto Profile Profile ( self , hydrad_root , time : Unit ( \"s\" ), ** kwargs ) Container for HYDRAD results at a given timestep. Typically accessed through Strand Parameters hydrad_root ( str ) : Path to HYDRAD directory time ( astropy.units.Quantity ) : grid_centers Spatial location of the grid centers grid_widths Spatial width of each grid cell grid_edges Spatial location of left edge of each grid cell spatial_average Profile . spatial_average ( self , quantity , bounds = None ) Compute a spatial average of a specific quantity column_emission_measure Profile . column_emission_measure ( self , bins : Unit ( \"K\" ) = None ) Computes the column emission measure, where it is assumed that the loop is confined to a single pixel and oriented along the LOS Parameters bins ( astropy.units.Quantity ) : temperature bin edges, including rightmost edge. If None (default), the bins will be equally-spaced in \\log{T} \\log{T} , with a left edge at \\log{T}=3 \\log{T}=3 , a right edge at \\log{T}=8 \\log{T}=8 , and a bin width of 0.05 0.05 . Returns em (astropy.units.Quantity) : the column emission measure in each bin bins (astropy.units.Quantity) : temperature bin edges. Note that len(bins)=len(em)+1 . peek Profile . peek ( self , ** kwargs ) Quick look at profiles at a given timestep. peek_emission_measure Profile . peek_emission_measure ( self , ** kwargs ) Quick look at the column emission measure coordinate Coordinate as a function of s s electron_temperature Electron temperature as a function of s s ion_temperature Ion temperature as a function of s s electron_density Electron density as a function of s s ion_density Ion density as a function of s s electron_pressure Electron pressure as a function of s s ion_pressure Ion pressure as a function of s s velocity Velocity as a function of s s level_population_hydrogen_1 Level population hydrogen 1 as a function of s s level_population_hydrogen_2 Level population hydrogen 2 as a function of s s level_population_hydrogen_3 Level population hydrogen 3 as a function of s s level_population_hydrogen_4 Level population hydrogen 4 as a function of s s level_population_hydrogen_5 Level population hydrogen 5 as a function of s s level_population_hydrogen_6 Level population hydrogen 6 as a function of s s","title":"pydrad.parse"},{"location":"api/visualize/","text":"pydrad.visualize Methods for plotting and animating HYDRAD output plot_strand plot_strand ( strand , limits = None , cmap = 'viridis' , ** kwargs ) Plot hydrodynamic quantities at multiple timesteps Parameters strand ( pydrad.parse.Strand ) : Loop strand object limits ( dict ) : Set axes limits for hydrodynamic quantities, optional cmap ( str ) : The colormap to map the timestep index to plot_kwargs ( dict ) : Any keyword arguments used matplotlib.plot, optional figsize ( tuple ) : Width and height of figure, optional animate_strand animate_strand ( strand , ** kwargs ) Return a matplotlib animation of time-dependent hydrodynamic quantities of a strand. Takes the same arguments as pydrad.visualize.plot_strand() . See the matplotlib animation docs for examples on how to write the movie to a file. plot_profile plot_profile ( profile , ** kwargs ) Plot hydrodynamic quantites at a single timestep Parameters profile ( pydrad.parse.Strand ) : Loop profile object limits ( dict ) : Set axes limits for hydrodynamic quantities, optional plot_kwargs ( dict ) : Any keyword arguments used matplotlib.plot, optional figsize ( tuple ) : Width and height of figure, optional plot_time_distance plot_time_distance ( strand , quantities , delta_s : Unit ( \"cm\" ), ** kwargs ) Make a time-distance plot for a particular quantity or quantities on a uniform grid. Parameters strand ( hydrad_tools.parse.Strand ) : quantities ( str , list , tuple ) : Name of quantity or quantities to plot. Optionally, you can also pass in a tuple of (str,array-like) , where str is the label and the second entry is the quantity to plot, already interpolated onto a common grid. norm ( dict , optional) : Dictionary of colormap normalizations; one per quantity.","title":"pydrad.visualize"}]}